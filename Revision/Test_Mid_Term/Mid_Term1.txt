C√¢u 1: V√¨ sao ƒë·ªÉ ƒë√°nh gi√° thu·∫≠t to√°n n√™n d√πng ph√¢n t√≠ch to√°n h·ªçc h∆°n ph√¢n t√≠ch th·ª±c nghi·ªám? H√£y
ƒë∆∞a ra 2 ƒëo·∫°n ch∆∞∆°ng tr√¨nh v√≠ d·ª• c√≥ th·ªùi gian O(1).
1. T·ªïng qu√°t h√≥a cho m·ªçi ƒë·∫ßu v√†o
Ph√¢n t√≠ch to√°n h·ªçc cho ph√©p ƒë√°nh gi√° hi·ªáu su·∫•t c·ªßa thu·∫≠t to√°n tr√™n m·ªçi ƒë·∫ßu v√†o, kh√¥ng ph·ª• thu·ªôc v√†o m√°y t√≠nh, tr√¨nh bi√™n d·ªãch, hay c·∫•u h√¨nh ph·∫ßn c·ª©ng.
Trong khi ƒë√≥, ph√¢n t√≠ch th·ª±c nghi·ªám ch·ªâ ph·∫£n √°nh hi·ªáu su·∫•t tr√™n m·ªôt s·ªë l∆∞·ª£ng h·ªØu h·∫°n c√°c ƒë·∫ßu v√†o c·ª• th·ªÉ.
2. ƒê·ªôc l·∫≠p v·ªõi m√¥i tr∆∞·ªùng th·ª±c thi
Ph√¢n t√≠ch to√°n h·ªçc kh√¥ng ph·ª• thu·ªôc v√†o ng√¥n ng·ªØ l·∫≠p tr√¨nh, CPU, RAM,...
Th·ª±c nghi·ªám c√≥ th·ªÉ b·ªã sai l·ªách do cache, t·ªëc ƒë·ªô b·ªô nh·ªõ, h·ªá ƒëi·ªÅu h√†nh,...
3. ƒêo l∆∞·ªùng ƒë·ªô ph·ª©c t·∫°p trong ƒëi·ªÅu ki·ªán l√Ω t∆∞·ªüng
Ph√¢n t√≠ch to√°n h·ªçc gi√∫p bi·∫øt tr∆∞·ªõc thu·∫≠t to√°n c√≥ tƒÉng nhanh hay ch·∫≠m khi d·ªØ li·ªáu l·ªõn l√™n, c√≤n th·ª±c nghi·ªám th√¨ kh√¥ng th·ªÉ ch·∫°y h·∫øt m·ªçi tr∆∞·ªùng h·ª£p.

v√≠ d·ª• 
#include <iostream>
using namespace std;

int tong(int a, int b) {
    return a + b;
}

int main() {
    int a = 5, b = 10;
    cout << "Tong la: " << tong(a, b) << endl;
    return 0;
}

C√¢u 2: Gi·∫£i th√≠ch m·ªëi quan h·ªá gi·ªØa f(n) v√† g(n) trong bi·ªÉu th·ª©c f(n) = O(g(n)). H√£y ƒë∆∞a ra 2 ƒëo·∫°n
ch∆∞∆°ng tr√¨nh v√≠ d·ª• c√≥ th·ªùi gian O(n).

Bi·ªÉu th·ª©c f(n) = O(g(n)) c√≥ nghƒ©a l√† t·ªëc ƒë·ªô tƒÉng tr∆∞·ªüng c·ªßa h√†m f(n) (th·ªùi gian ch·∫°y th·ª±c t·∫ø c·ªßa thu·∫≠t to√°n) kh√¥ng v∆∞·ª£t qu√° m·ªôt h·∫±ng s·ªë nh√¢n v·ªõi g(n) khi n ƒë·ªß l·ªõn.

üëâ C·ª• th·ªÉ:

C√≥ t·ªìn t·∫°i h·∫±ng s·ªë d∆∞∆°ng c v√† n‚ÇÄ sao cho:

‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉf(n) ‚â§ c √ó g(n) v·ªõi m·ªçi n ‚â• n‚ÇÄ.

üìå √ù nghƒ©a:
g(n) l√† h√†m b·∫≠c tr√™n ƒë·ªÉ ∆∞·ªõc l∆∞·ª£ng ƒë·ªô ph·ª©c t·∫°p.

Ta d√πng O(g(n)) ƒë·ªÉ bi·ªÉu di·ªÖn ƒë·ªô ph·ª©c t·∫°p th·ªùi gian t·ªá nh·∫•t (worst-case).

f(n) c√≥ th·ªÉ nh·ªè h∆°n ho·∫∑c b·∫±ng g(n) (nh√¢n v·ªõi 1 h·∫±ng s·ªë) khi n ƒë·ªß l·ªõn.

C√¢u 3: 
bool binarySearch(int arr[], int n, int x) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2; 
        if (arr[mid] == x)
            return true;
        else if (arr[mid] < x)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return false;
}
| 0 | 1 | 2 | 03 | 04 | 05 | 06 | 07 | 008 |
| 2 | 5 | 7 | 11 | 12 | 20 | 22 | 30 | 104 |
find x = 3
mid = 4  => arr[4] > 3 => left = 0 right = 3
mid = 1  => arr[1] > 3 => left = 0 right = 0
mid = 0  => arr[0] < 3 => left = 1 right = 0 break

C√¢u 4: 4. Khi √°p d·ª•ng thu·∫≠t to√°n tuy·∫øn t√≠nh tr·ªôn 2 m·∫£ng a, b tƒÉng th√†nh m·ªôt m·∫£ng c tƒÉng (h√¨nh d∆∞·ªõi), ta
c·∫ßn bao nhi√™u ph√©p so s√°nh ph·∫ßn t·ª≠ c·ªßa a v·ªõi ph·∫ßn t·ª≠ c·ªßa b?
a = [2, 22, 30]        (3 ph·∫ßn t·ª≠)  
b = [5, 7, 11, 12, 20, 104]  (6 ph·∫ßn t·ª≠)  
c = [2, 5, 7, 11, 12, 20, 22, 30, 104]
1. a[0] < b[0] ch√®n 2 i++
2. a[1] = 22 b[0] = 5 => a[1] > b[0] ch√®n 5 j++
3. a[1] = 22 b[1] = 7 => a[1] > b[1] ch√®n 7 j++
4. a[1] = 22 b[2] = 11 => a[1] > b[2] ch√®n 11 j++
5. a[1] = 22 b[3] = 12 => a[1] > b[3] ch√®n 12 j++
6. a[1] = 22 b[4] = 20 => a[1] > b[4] ch√®n 20 j++
7. a[1] = 22 b[5] = 104 => a[1] < b[5] ch√®n 22 i++
8. a[2] = 30 b[5] = 104 => a[2] < b[5] ch√®n 30 i++
=> a h·∫øt ph·∫ßn t·ª≠ -> ch√®n ph·∫ßn c√≤n l·∫°i c·ªßa b

C√¢u 5: 
Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p th·ªùi gian c·ªßa ƒëo·∫°n m√£ sau:
int mystery1(int n){
    int sum = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            sum += i * j;
        }
    }
}
O(n^2)
C√¢u 6: O(n^3)
C√¢u 7: 
int mystery2(int a[], unsigned int n)
{
    int sum = 0;
    int thisSum = 0;
    for (int i = 0; i < n; i++) {
        thisSum += a[i];
        if (thisSum > sum)
            sum = thisSum;
        if (thisSum < 0)
            thisSum = 0;
    }
    return sum;
}
O(n)
C√¢u 8:
n*(n-1)/2
C√¢u 9:
a) ngƒÉn x·∫øp b·∫±ng m·∫£ng tƒ©nh
bi·∫øn top ƒë·ªÉ l∆∞u ƒë·ªânh ngƒÉn x·∫øp
kh·ªüi t·∫°o top = 0
push a[top] = val
top++
erase top--
top a[top - 1]
b) danh s√°ch li√™n k·∫øt ƒë∆°n
kh·ªüi t·∫°o top ƒë·ªÉ l∆∞u ƒë·ªânh ngƒÉn x·∫øp
kh·ªüi t·∫°o count ƒë·ªÉ l·∫•y size c·ªßa ngƒÉn x·∫øp
push t·∫°o m·ªôt node m·ªõi n·ªëi top v√†o node m·ªõi c·∫≠p nh·∫≠t top l√† node m·ªõi ƒë√≥ t·∫Øng count++
pop top=top->next;
gettop ch√≠nh l√† top
c) danh s√°ch li√™n k·∫øt ƒë√¥i
kh·ªèi t·∫°o top l∆∞u ƒë·ªânh ngƒÉn x·∫øp
push : t·∫°o node n·ªõi, if top != null top->next = newnode, newnode->prev = top, c·∫≠p nh·∫≠t top = newnode
pop : top = top->prev, top->next = null
peek : top
C√¢u 10:
c√°i b ko h·ª£p l√Ω
C√¢u 11:
b ,c , d ƒë·∫øu ko h·ª£p l·ªá
C√¢u 12:
C√†i ƒë·∫∑t h√†ng ƒë·ª£i 
a) b·∫±ng m·∫£ng tƒ©nh
font theo d√µi ƒë·∫ßu h√†ng ƒë·ªçi = 0
rear theo d√µi cu·ªëi h√†ng ƒë·ª£i = 0
enqueue: th√™m v√†o th√¨ a[rear] = val, c·∫≠p nh·∫≠t size++,c·∫≠p nh·∫≠t rear v√†o c√°c ch·ªó c√≤n tr·ªëng rear;
dequeue: a[font], c·∫≠p nh·∫≠t font;
b) c√†i ƒë·∫∑t b·∫±ng danh s√°ch li√™n k·∫øt ƒë∆°n
kh·ªèi t·∫°o font theo d√µi ƒë·∫ßu h√†ng ƒë·ª£i = NULL
Kh·ªèi t·∫°o reat theo d√µi cu·ªëi h√†ng ƒë·ª£i = NULL
enqueue : t·∫°o node m·ªõi, n·∫øu rear = null th√¨ font = rear = node m·ªõi, n·∫øu kh√¥ng th√™m node m·ªõi v√†o h√†ng ƒë·ª£i rear->next = newNode, c·∫≠p nh·∫≠t rear = newNode, c·∫≠p nh·∫≠t size
dequeue : font = font->next, c·∫≠p nh·∫≠t xong m√† r·ªóng th√¨ c·∫≠p nh·∫≠t rear c≈©ng b·∫±ng r·ªóng, size--
C√¢u 13:
            x
          /   \
        2       +
              /   \
            4       +
                  /   \
                5       3
duy·ªát postorder ƒë·ªÉ in ra postfix
2 4 5 3 + + x
ƒê·ªçc 2
ƒë·∫©y v√†o stack[2]
ƒê·ªçc 4 
ƒë·∫©y v√†o stack[2 ,4]
ƒê·ªçc 5 
ƒë·∫©y v√†o stack[2, 4, 5]
ƒê·ªçc 3
ƒë·∫©y v√†o stack[2, 4, 5, 3]
ƒê·ªçc '+'
pop(3, 5)
ƒë·∫©y v√†o stack(5 + 3) stack[2, 4, 8]
ƒê·ªçc '+'
pop(4 , 8)
ƒë·∫©y v√†o stack(4 + 8) stack[2, 12]
ƒê·ªçc '*'
pop(2, 12)
ƒë·∫©y v√†o stack(2 * 12) stack[24]
print stack.top
C√¢u 15:
             8
           /   \
         3       10
       /   \       \
     1      6        14
           /  \     /
          4    7   13
                  /
                11
a) insert 11
if(root == null) {
    root = new TreeNode(val);
    return root
}
else {
    if(11 > 8) {
        root->right = IS(10,11)
                        |
                      if(11 > 10) {
                        root->right = IS(14,11)
                                          |
                                      if(14 > 11) {
                                        root->left = IS(13,11)
                                                        |
                                                     if(13 > 11) {
                                                        root->left = IS(null, 11) = 11
                                                     }
                                      }
                      }
                    
    }
}
C√¢u 16:
               16
             /    \
            6     20
          /   \
         2    11
                \
                12



               12
             /    \
            6     20
          /   \
         2    11
C√¢u 17:
insert(root,val) {
    IF(root = NULL) t·∫°o node m·ªõi TreeNode(val); return root
    ELSE {
        IF(val < root-> val) root->left = insert(root->left,val)
        ELSE root->right = insert(root->right, val)
    }
}
deleteMin(root) {
    IF(root = NULL) return NULL
    IF(root->left = NULL) {
        minval = root->val;
        TreeNode* rightChild = root->right;
        delete root;
        return rightChild;
    }
    root->left = deleteMin(root->left)
}
C√¢u 19:
class ArrayStack {
public:
    ArrayStack(): element(NULL), capacity(0), t(-1){}
    // C√°c ph∆∞∆°ng th·ª©c kh√°c c·ªßa ngƒÉn x·∫øp
    void push(int x);
private:
    int * element; // con tr·ªè t·ªõi m·∫£ng c·∫•p ph√°t ƒë·ªông
    int capacity; // dung l∆∞·ª£ng m·∫£ng ƒë·ªông
    int t; // ch·ªâ s·ªë m·∫£ng c·ªßa ph·∫ßn t·ª≠ ƒë·ªânh ngƒÉn x·∫øp
};
void ArrayStack::push(int x) {
    // N·∫øu m·∫£ng ƒë·∫ßy, c·∫•p ph√°t m·∫£ng m·ªõi c√≥ k√≠ch th∆∞·ªõc l·ªõn h∆°n (g·∫•p ƒë√¥i)
    if(t + 1 = capacity) {
        int newCapacity = (capacity == 0) ? 1 : capacity*2
        int* newElement = new int[newCapacity]
        // Sao ch√©p d·ªØ li·ªáu c≈© sang m·∫£ng m·ªõi
        for (int i = 0; i <= t; ++i) {
            newElement[i] = element[i];
        }

        // Gi·∫£i ph√≥ng m·∫£ng c≈©
        delete[] element;

        // C·∫≠p nh·∫≠t con tr·ªè v√† dung l∆∞·ª£ng
        element = newElement;
        capacity = newCapacity;
    }
     // Th√™m ph·∫ßn t·ª≠ m·ªõi v√†o ƒë·ªânh ngƒÉn x·∫øp
    element[++t] = x;
}